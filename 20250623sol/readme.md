# EVM 에서 실행할수 있는 솔리디디 컨트랙트

## contract
> byte 코드로 변환해서 네트워크에 기록
> EVM의 스토리지에 영구적으로 저장되고 블록에 기록된다

### EOA
> 계정 사용자가 있는 계정
> 트랜잭션을 발생시키기 위해서 사용한다.

## contract로 만등 계정 CA
> 컨트랙트 계정
> 배포된 컨트랙트는 블록에 기록되고 코드의 내용은 EVM에서 저장하고 사용한다.


### solidity
> 이더리움 블록체인에서 스마트 컨트랙트를 작성하기 위해서 만들어진 상위 프로그래밍 언어
> 계약서를 작성할수 있는 프로그램
> 브트코인은 복잡한 계약을 작성할수 없었다
> 2013 년 비탈릭 부테린이 이더리움 백서를 작성
> 2015년 이더리움 메인넷 출시
> 이더리움 네트워크에서 블록체인 위에 조건을 가진 계약을 작성할수 있게 제공되었다
> 계약서를 작성할수 잇도록 제공해주는도구가 솔리디티

#### 솔리디티 장점
> (우리한테 장점) javascript 와 비슷한 문법을 기지고 있다
> 이더리움 네트워크의 가상 머신 EVM에서 싫생이 가능한 바이트 코드를 컴파일할수 있다.
> 스마트 컨트렉트를 작성할때 가장 많이 사용하는 언어

#### 스마트 컨트렉트 계약
> 조건이 충족되면 자동을 ㅗ실행되는 코드의 내용을 작성
> 절차지향 코드를 작성하면 된다
> 중앙기관이 없이 실행된다 => 이더리움 네트워크에 EVM에서 실행을 하고 상태변수로 저장 블록에 기록


#### solidity writing
```js
class Counter {
    value : number;     // 상태 변수
    constructor() {
        setValue(){}    // 상태변수 전환 함수 트랜잭션 발생시
        getValue(){}    // 조회 메시지 발생
    }
}
// 컨트랙트 배포

const _0x321 = new Counter();
// 컨트랙트 주소를 받아서
// CA로 => 요청
// RPC (REMOTE PROCEDURE CALL) 통신 웤격 프로시저 호출 => 응답을 받는게 목적이 아니고
// 단순한 데이터를 다루고 프로세서 즉 evm에서 실행기켜줘라
_0x321.setValue()

```
> solidity 문법은 자바스크립트의 클래스 문법과 많이 유사하다
> // SPDX-License-identifier: MIT  코드작성할때 첫줄에 포함되어야한다
> 주석도 읽어서 // SPDX-License-identifier: MIT 이 구문을 읽는다
> 누구나 사용 가능한 자유로운 라이센스
> 법적인 명확성 코드가 어떤 조건 내에서 배포가 되었는지 표현할수 있다.
> MIT 라이센스는 사용 복사 수정 병합 게시 배포 등등 모두 가능한 리이센스
> 오픈소스를 따라서 개발한다
> 크립토 좀비
```JS
// SPDX-License-identifier: MIT
pragma solidity 0.8.30;

contract Counter {
    uint Count = 0; // uint = unsigned integer positive number (양수)      음수 (negative number)
    address count2;
    // 컨트랙트 배포할때 딱 한번 => 배포가 되어서 CA가 생성될때 
    constructor(address _CA) {
        // 누군가에세 에어드랍 준다
        count2 = _CA
        setValue()
        address _CA = new Counter2();
        // _CA 
    }

    // 접근자 (어디에서 쓸수 있나?)
    // 상속도 가능하고 주소만 가지고 사용도 가능하다
    // 하나의 컨트랙트가 되는것이 상속
    // 주소를 알고있는것은 컨트랙트가 2개 
    function setValue(uint _count) public {
        Count += _count;
    }
    // 조회만 가능한 함수 수정자 view
    // 가스비 발생이 되지 않은 함수
    function getValue() public view {
        return Count;
    }
}

// compile then ABI and byte code will be created
// EOA => bytecode 만 가지고 트랜잭션 보낸다
// EVM 저장소 bytecode 저장되고 
// 블록에 기록되고 CA 생성된다 => CA 주소로 이후에 요청을 보낼때 CA 를 포함시키고 호출할 메서드 이름을 포함시켜서 요청보내면 호출이 된다

// ABI 메타데이터 바이너리 코드를 사용할때 제공되는 인터페이스
// 요청 보낼때 컨트랙트를 참조해서 메서드를 호출학때
// setValue ABI 에 있는 setVAlue 메서드의 내용을 바이트 코드로 변환
// EVM 에서도 사용할수 있는 바이트 코드 어떤 메서드 호출할지 사용자도 어떤 메서들를 호출할지 객체에 담아서
{
    setValue : {
        type : ""
        input : {

        }
        output : {

        }
    }
}

```


### 우리가 작성할수 있는 레벨의 언어로 표현하는것이 솔리디티
1. 라이센스 정보
2. 솔리디티 버전
3. 컨트랙트 내용

> javascript 클래스는 인스턴스를 생성하는 과정이 new 키워드를 사용해서 만들었다
> new 키워크를 통해서 생성된 인스턴스들은 다른 메모리 공간을 가지고 있게 된다. new로 생성된 모든 객체는 다른 주소를 가지고 있다.
> 컨트랙트는 객체를 하난 생성하고 모든 사용자 컨트랙트 사용자들은 하나의 인스턴스를 사용하는방식으로 CA 주소를 모두 알고 요청을 보내서 사요하는것 => singletone pattern


### 배포 프로세스 
1. 컨트랙트 코드 작성
2. 컨트랙트 코드 컴파일
3. 트랜잭션 메시지 생성 (보내는 사람, 가스비, 가스당 가격, data 메시지 내용 )
4. 개인키 서명 하면서 트랜잭션 발생
5. 트랜잭션이 블록이 생성되고 기록되어서 처리되면 CA의 값ㅇ르 받을수 있고 받은 CA에는 codehash에 바이너리 코드가 저장된다.
6. CA 를 가지고 트랜잭션을 보낼때 메시지로 ABI 의 내용을 바이트코드로 변환해서 요청보내면 해다 메서드를 호출한다
7. 블록이 생성되고 트랜잭션 처리가 끝나면 EVM이 실행 결과를 상태변수에 반영이 애뇽ㅇ도 블록에 기록되러 있다.



### 메타마스크
> 테스트 이더
> 개인키 서명 => 서명 생성해서 트랜잭션에 포함 (우리가 수동으로 해도 되지만)
> 개인키 서명을 만들어서 트랜잭션에 포함 => 지금 사용하는 컴퓨터 로컬에 개인키가 저장이 되어있다
> 마스터키 지갑안에 겨정을 여러개 만들수 있다 암호화된 시트를 저장해서 보관하고 있다가
> 이 시드를 가지고 마스터키를 복원할수 있다.

### 니모닉
> 비밀 백업 구문 => 니모닉
> 니모닉은 BIP-39(비트코인 제안서 커뮤니티에서) 표준에 따른 사람이 읽기 쉬운 방식의 시드 형태 문구
> 12, 15, 18 등 단어의 조합을 가지고 있다
> 무작위 바이트를 사람이 일기쉬운 영어 단어로 바꾼것.
> 니모닉 -> 마스터키 -> 개인키 공개키를 만드는 구조(개인키중에 하나가 공개되어도 마스터키 역산은 불가능)
> 지갑에 접속할때 포함시킨 비밀번호 + 니모닉으로 시트를 만든다

> 공개키에 이더 송금할수 잇다

### 네트워크 통신
> 노드를 운영하지 않고 설치 => 
> 큰기업들이 제공하는 이더리움 제단 등 바이낸스
> rpc 엔드포인트를 받아서 공급자 역활을해서 우리한테 노드 이용을 할수 있게 오돠주겠다
> 우리가 서명을 만들어서 보내서 그 메시지를 노드 이욜을 해주는것
> 우리가 사용할 곡급자 


### web3 라이브러리
> 이더리움 네트워크랑 상호작용을 할수 있도록 도와주는 공급자 역활
> 브라우저 혹은 nodejs 환경에서 네트워크와 통신을 도와준다


script 에 web3 npm cdn 검색하고
    <script src="https://cdn.jsdelivr.net/npm/web3@4.16.0/dist/web3.min.js"></script>


### 카운트 구현
1. html 구현 계정 UI

2. 카운트 호출 (컨트랙트 작성후 컴파일 ABI bytecode)

- solc 라이브러리 사용
```sh
npm i -g solc;

npx solc --bin --bin filename -o 내보낼경로
```


### 비트코인 내용 내일 병가  