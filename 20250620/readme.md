# etherum network

> etherum 만든 사람은 비탈릭 부테린 비트코인을 옹호하는 느낌을 많이 받았다
> 기술적인 부분은 비트코인 백서에서 이미 알고 있다. 이더리움 백서에서는 백서에서는 비트코인의 확장된 내용을 많이 서술해두었다
> 비탈릭 부테린이 게임을 좋아했는데
> 이더리움 넷워크를 만들때 생각이 본인이 키우던 게임 게릭터랑 아이템이 한순간 사라지면서 아쉬움을 느꼈다.
> 비트코인은 화폐를 집중해서 만든 네트워크. 이더이움의 네트워크는 단순하게 화폐만 아닌 플렛품 개발을 목적으로 만들었다.(컨트랙트 개발이 가능한 이유) (이더리움 코인 돈처럼 쓰는데) 이더리움 네트워크는 화폐를 기준으로 만든 네트워크가 아니다. 
> 비트코인의 한계를 보완하기 위해서 시도를 한 네트워크


## 이더리움 백서의 제목(차세대 스마트 컩트랙트와 탈중앙화된 어플리체이션 플랫품)

> A => B = 그다음은요? (비트코인 네트워크) => 간단한 스크립틍 (플랫품 비트코인으로 구현한다. 다중 서명 처리)
> A (돈 송금) => B = B 는 A 에게 보상을 줍니다. 서명처리는 EVM 가성 머신과 이더리움 네트워크에서 제공해준다 => 플랫폼을 개발할수 있는 환경을 제공해줄게
> 이더리움은 플랫품에 포커스가 맞춰져 있고 비트코인은 화폐에 포커스가 맞춰져 있다.
> 이더리움 네트워크의 제안은 탈중앙화된 어플리체이션을 만들어라 제안


### 상태 변환 시프템
> 이더리움 백서에서 비트코인의 트랜잭션을 `상태 변환 시스템` 
> 비트코인은 트랜잭션에서 출력값을 UTXO 라는 객체에 저장을 했는데
> 이더리움은 트랜잭션을 상태 처리 => 우리가 배운 내용에서는 추상적으로 리액트 상태라고 뵈도 무방하다.
> 간단하게 상태를 설명하면 

### 쇼핑몰의 상품 구매 상태
- 상품 구매 프로세스
- 상품의 구매의 상태를 표현하는 테이블이 하나 있다

> 상태라는 용어 
**1. 주문 접수 -> 2. 결제 확인 -> 3. 상품 준비 -> 4. 상품 발송 -> 5. 상품을 수령(배송 완료)**

> UTXO -> transaction -> UTXO
> 잔액을 확인하고 지갑 주소의 잔액을 표현하는 값을 잔액 객체로 저장
> 새로운 거래를 생성해서 트랜잭션 처리가 되면 새로운 UTXO를 만들어 주었다. EOA
> UTXO라는 용어를 사용하지 않고 어카운트 라는 표현을 사용한다
> 비트코인에서 UTXO의 변경은 이더리움 네트워크에서 표현을 바꿔서 상태가 변화되었다.

#### 비트코인의 스크립팅
> 비트코인은 정말 낮은 수준의 컨트랙트와 유사한 있었고
> 비탈릭 부테린은 서명에 관련된 로직을 스마트 컨트랙트라는 시점으로 바라보고 있다. (다중 서명 로직을 처리할수 있는 형태를 제공하면 어떨까)
> 비트코인은 UTXO는 공개키 만으로 해당 계정의 잔액을 조회할수 있는데
> 단순 스택 기반의 프로그래밍 언어로 표ㅕ현되어있다
> 비트코인은 2, 3, 개 이상의 개인키를 가지고 서명을 만들어서 검증할수 있는 스크립틍을 작성해야 플랫품을 구현할수 있다 (구상하기 어렵고 실용성이 많이 떨어진다.)
> 그래서 이더리움은 이 내용을 스마트 컨트랙트의 개념으로 바라보고 제안했다.

#### 이더리움 네트워크
> 이더리움을 짧게 문자로 서술했을때
> 이더리움의 목적은 분산 어플리케이션 제작을 위한 대체 프로토콜
> 탈중앙 디앱을 생상하는 이유
1. bitcoin 을 가지고 예금, 보험 및 금윰 상품에 대한 것을 구현할수가 없다 (이자를 구현 X )
2. 사이트 및 게임에 적용하기 힘든 부분을 구현할수 없다( 상품 및 게임 아이템 매칭 )
> 비트코인은 만든다고 가정하면 결제에 포커스가 맞춰져 있기 떄문에 결제에 대한 부분만을 처리한다.
> 이자의 부분만 따로 보완을 해서 처리를 하는 방향이 맞다
> 이더리움의 목적은 이러한 형태를 구현할수 잇는 플랫품을 만든것
> 적은 시간을 들여서 탈중앙 앱을 DAPP 을 만드는데 탈중앙 데이터를 저장할수 있는 사이트를 쉽게 개발할수 있다
> 탈중앙 통신을 할수 있는 프로토콜을 쉽게 유저가 사용할수 있도록 구현 가능하다.
> 탈중앙 데이터를 저장 할수 있다 => 스마트 컨트랙트
> UTXO 의 형식적니 화폐의 데이터가 아닌 상태 즉 상태의 변화를 만들어서 ㅠ다야한 데이터를 저장하고 사용할수 있도록 트랜잭션의구조가 완전히 바꿘것


#### 이더리움 (UTXO 의 변화)
> 이더리움에서 는 상태 (state)는 account라는 객체로 구성되어있다
> account

```js
interface account {
    nonce : number; // 계정이 발생시킨 트랜잭션의 횟수 , 이중 지불의 방지용으로 사용되는
    balance : string; // ethereum
    storageRoot : string; // account 의 상태를 저장하고 있는 공간(머클 패트리샤)
    codeHash : string // 스마트 컨트랙트 계약의 코드 스마트 컨트랙트 배포를 하면 컨트랙트로 작성한 코드의 내용이 바이트코드로 변환되어서 저장된다 블록에 기록이 되고 변조가 불가능 (프록시 패턴을 사용해서)
}
```

> 이더라는 이더리움 플랫품의 화폐단위가 있고 
> 츠랜잭션을 발생 시킬때 수수료로 지불 하는데 사용
> 코드 해시에 있는 메서드를 호출해서 스토리지 루트의 상태를 변환할때 이더라는 화폐를 지불해서 상태를 변환할수 있게 설계했다.

### 이더리움 네트워크의 튜링 완전 (엘런 투링)
> 컨트랙트로 작성해서 저장된 바이트 코드가 실행되는 런타임 환경
> EVM 이 없으면 컨트랙트를 호출할수 없다
> 튜링 완전 기계 : 조건문 반복문 등등 의 모든 계산은 가능한 계산이다. => 가스비
> EVM 구조와 동작 원리는 
> 256비트의 워드 크기를 사용하는 스택과 메모리와 저장소 3 가지의 주요 공간을 가지고 있다.

> 스택 : 임스 저장 데이터 연산 처리할때 스마트 컨트랙트 실행중
> 메모리 : 임시 저장 공간 휘발성 함수 실행중에 할당하는 중간 데이터
> 저장소 : 영구  데이터 저장소 상태가 변화하면 겨기에 영구저장된다. 스마트 컨트랙트의 상태 저장

> 스마트 컨트랙트는 실행이 계산이 되어야 실행될수 있는 형태의 코드를 제공한다.
> 스마트 컨트랙트의 코드는 바이트코드 형태로 실행을 한다.
> opcode를 사용할때 => 140개 가량 많은 명령어 하나에 바이트가 1 바이트

### OPCODE

```js
ADD 두값을 더한다 => 3GAS

```

#### 스마트 컨트랙트의 흐름
1. 트랜잭션을 블록에 포함하고 EVM에서 실행 트리거 (상태를 업데이트)
2. 트랜잭션의 data 필드에 있는 호출 대상으로 지정된 컨트랙트의 함수와 매개변수를 해석해서
3. EVM 은 명령어를 하나씩 해석해서 스택과 메모리를 사용해서 계산 연산 수행
4. 저장소에 상태 저장을 한다. 상태 저장이 완료되면 블록체인 변화가 된거고 전파
5. 실행이 완료되면 결과에 따른 GAS가 소모된다.

#### EVM (이더이움 네트워크의 가장크 특징)
- smart contract 는 EVM 에서 완벽하게 매부 구조에 위험성은 배제하고 격리시켜서 실행을 한다. 시스템에 직접 접근 불가능하게 구성했다. ( 격리성) 
- 결정성 : 모든 노드의 동일한 결과를 내도록 보장하는 합의를 설계헀다
- 가스의 메커니즘 : 무한루프 코드나 공격성있는 코드의 방지를 위해서 계산이 가능한 코드를 계산량에 따라 수수료 비용을 부과했다.
- 스마트 컨트랙트 배포 : 생성 트랜잭션을 바이트 코드로 저장소에 저장한다.

> 노드에 포함되어 있는것. => 풀노드(EVM) 에만 포함된다, 라이트 노드  

### EOA 이더리움 어카운트 
> 이더리움에는 상태와 ACCOUNT 라고 하는 객체로 구성되어 있다

```js
interface Account {
    nonce : number;
    balance : string;
    storageRoot : string;  // 사용하지 않는다
    codeHash : string;  // 사용되지 않는다
}
```

> 이더리움의 어카운트는 2 가지의 형태가 있다 
> 노드에 포함되어있는것
> EOA 가 있고 이 계정은 사용자가 사용하는 계정
> CA 가 있다, contract address

#### CA 
```js
interface Account {
    // 다 사용된다
    nonce : number;
    balance : string; // 이더리움
    storageRoot : string; // 유저의 주문 상태
    codeHash : string;  // ADDRESS FOR THE CONTRACT CODE
}
```

> 컨트랙트의 주소에 있는 계정은 모든 값을 사용한다. EOA에서는 nonce 랑 balance만 사용된다
> 컨트랙트 코드를 우리가 만들고 빌드 => ABI(applicaion binary interface), byte 코드 => 바이트 코드를 네트워크로 요청
> 내가 배포한 컨트랙트 저장 => CA (HASH문자열) 

#### EOA, CA
> EOA (EXTERNALLY OWNED ACCOUNT) : 사용자 지갑
> CA (CONTRACT ACCOUNT) : 내가 배포한 컨트랙트의 주소
> 서명을 할수 있느냐? 없느냐?

> EOA => (트랜재션) => CA =>(메시지) CA
> CA => CA (이거는 불가능)

> 개인키가 있냐 없냐?
> 사용자 지갑은 개인키가 있다.
> 컨트랙트 계정은 개인키가 없다.
> 개인크를 가지고 만든 공개키가 이더리움의 계정을 가르키는 값이
> 개인키로 서명을 만들어서 상태 변화 처리를 한다. 네트워크의 값ㅇ르 변경 즉 상태를 변경하기 위해서는 서명이 무조건 필효하다.
> EOA 만 트랜잭션을 발생 시킬수 있다


#### 메시지와 트랜잭션
> 이더리움에서 서명이 없는 영수증 즉 트랜잭션은 서명이 있는 영수증
> 서명이 없는 영수증은 메시지라고 한다.
> 서명의 유무는 개인키의 유무와 직결된다.

> EOA 계정이 트랜잭션을 발생 시킬수 있는 이유
> CA는 트랜잭션을 발생 시킬수 없다 MESSAGE를 발생 시킬수 있다.

```ts
// 메시지
interface Message {
    from : string; // 보내는 계정
    to : string; // 받는 사람
    gas : number; // 가스당의 가격 
    gasPrice : number; // 가스당의 가겻
    value : number; // 트랜잭션을 전달할때 계정에 전달할 이더량
    data : string; // 메시지의 데이터
    nonce : number; // 메시지를 전송한 트랜잭션 몇번 메시지 몇번 횟수
}
// 가스의 가격이 정해지는 때 처리가 될때 (네트워크 복잡도 + 가스당 가겻 + 내 코드의 가스 가격)
// 트랜잭션은 메시지를 포함하고있다. 라고 객체의 구조를 정의했을때
// 저장소의 값ㅇ르 변경한다라는 것은 튜링 완전의 머신을 계산이 되어야하는 머신 가스비
// 네트워크 자원을 쓴다 한정적인 연료
interface Transaction extends Message {
    v : number;
    r: string;
    s : string;
}

```
#### 이더리움 GAS 
> EVM 상에서 트랜잭션을 처리하기 위해서 소모되는 자원
> 코드의 복잡성에 따라서 측정이 되기 때문에 가스량은 요청하기 전까지 알수 없다
> (네트워크 복잡도 + 가스당 가격 + 내 코드의 가스 가격)
> Gas 의 가격은 거래가 걸리는 시간에도 영향을 준다 => 가스비가 비싸면 더 빠르게 처리된다
> 사용자가 GAS당의 가격을 설정해서 수수료를 조정해서 더빠르게 처리할수 있다
> 이더의 화폐 단위가 나눠져있는데 나눠진 궁극적인 목표는 수수료의 단위를 계산하기 위해서 1000 원짜리 500 원짜리 100 원짜리
> 가스를 계산하기 단위는 Gwei (gigawei) Gwei 1 eth = 1.000.000.000Gwei 가스를 계산하기위한 단위
> 기본 가스당 금액은 21.000 * 100 
> byte 당 대략 5GAS로 측정한다


#### 메타 마스크 설치
> google chrome 에서 확장 프로그램에서 설치 
> 지갑 생성 복구문 저장
> sepolia 수도꼭지, 